---
title: dplyr3 - reshaping
output: 
  html_document:
    toc: true
    theme: united
---

This functions in dplyr allow us to reshape data. Instead of changing individual columns, we can instead move from wide to tall format. 

See [dplyr tutorial](https://dplyr.tidyverse.org/articles/dplyr.html) for more help.


## pivot

We often want to transition data from a wide format to tall, and vice versa.

This was moved from `dplyr` to the `tidyr` package.

### wider

Going wide means we take multiple rows and turn them into a single row with multiple columns.

The two key arguments are:

- `names_from` is a field, each value will turn into a new column
- `values_from` is a field, each value will turn into the data for a new column

```{r, eval=T, echo=TRUE }
library(tidyverse)

t_long <- tibble(
  state = c('CA', 'CA', 'CA', 'TX', 'TX', 'TX'),
  year = c(2000, 2001, 2002, 2000, 2001, 2002),
  sales = c(1, 2, 3, 11, 12, 13)
)

t_wide <- t_long %>% 
  pivot_wider(names_from = year, values_from = sales )

print(t_wide)
```


### longer

Going long/tall means we go from a single row with multiple columns and into multiple rows with a single column.

The three key arguments are:

- `cols` are the fields/columns we should remove
  - Name individual items in a vector, i.e. `c(field1, field2)`
  - Use anything that works in `dplyr::select`
    - `field1:field10` selects all of the columns from one field to another. Very good for year columns
    - `starts_with('value')` picks all fields with the beginning value.
- `names_from` is a "string" to call the new column for the names
- `values_from` is a "string" to call the new column for the values

```{r, eval=T, echo=TRUE }
library(tidyverse)

t_wide <- tibble(
  year = c(2000, 2001, 2002),
  ca = c(1, 2, 3),
  tx = c(11, 12, 13)
)

t_long <- t_wide %>% 
  pivot_longer(cols = c(ca, tx), names_to = 'state', values_to = 'sales' )

print(t_long)
```

# Less commonly used dplyr commands

## slice_min/max {.tabset}

We can use slice_max and slice_min to find the rows with the highest and lowest values in a field.

### slice_min when n = 1

`slice_min` pulls the rows with the lowest value in the given field. It respects the current grouping level. When pulling a single value, it is basically identical to `min(field_name)`. 
`slice_max` is the same, but pulls the largest item instead of the smallest.

```{r, eval=T, echo=TRUE, message=F }
library(tidyverse)

t <- tibble(
  region = c('a', 'b', 'c', 'a', 'a', 'b'),
  sales = c(0, 10, 5, 3, 2, 1)
)

# Group and then find smallest value
t <- t %>% 
  group_by(region) %>% 
  slice_min(sales, n = 1) # same as summarize(sales = min(sales))

print(t)
```


### slice_min when n > 1

When given `n > 1`, slice will pull multiple rows.

```{r, eval=T, echo=TRUE, message=F }
library(tidyverse)

t <- tibble(
  region = c('a', 'b', 'c', 'a', 'a', 'b'),
  sales = c(0, 10, 5, 3, 2, 1)
)

# Group and then find the 2 smallest items from each group
t <- t %>% 
  group_by(region) %>% 
  slice_min(sales, n = 2) 

print(t)
```

## relocate

The relocate verb moves columns in a table. It is handy when you are looking for a table to be in a certain order.


## References

The book "R for Data Science" is very good. Below are several key chapters:

- [tibble](https://r4ds.had.co.nz/tibbles.html)
- [Data import](https://r4ds.had.co.nz/data-import.html)
- [Tidy Data](https://r4ds.had.co.nz/tidy-data.html)
- [Relational data](https://r4ds.had.co.nz/relational-data.html)

